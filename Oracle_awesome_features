
--custom ordering
select * from (
  select 'hello' as name, null as val from dual
  union
  select 'yelow' as name, 20 as val from dual
  union
  select 'wellow' as name, null as val from dual
  union
  select 'zello' as name, 50 as val from dual
) order by decode(val, 50, 1, null, 2, 20, 3, 4);

--another way
order by 
    case 
       when val = 50 then 1 
       when val = null then 2
       when val = 20 then 3
       else 4
    end
    
    
--handling order in nulls:
select * from (
select 'hello' as name, null as val from dual
union
select 'yelow' as name, 20 as val from dual
union
select 'wellow' as name, null as val from dual
union
select 'zello' as name, 50 as val from dual
) order by val desc nulls first;

--Order by first column followed by second column
select * from (
select 'hello' as name, null as val from dual
union
select 'yelow' as name, 20 as val from dual
union
select 'wellow' as name, null as val from dual
union
select 'zello' as name, 50 as val from dual
) order by 1 ASC, 2 DESC

--fetch n rows clause
select * from (
select 'hello' as name, null as val from dual
union
select 'yelow' as name, 20 as val from dual
union
select 'wellow' as name, null as val from dual
union
select 'zello' as name, 50 as val from dual
) order by val
fetch first 50 percent rows only
--fetch first 3 rows only
--offset 1 rows fetch next 3 rows only
--offset 2 rows fetch 50 percent rows only
--fetch first 2 rows wth ties;

-- in case  of offset with percentage percentage will be calculated on master set and not after the offset
-- in case of fetch n rows with ties in order by val it will fetch n+1 or n+2 records in case two records have same values


--Substitution variables
-- use single ampersand to use value on run time and delete the variable after use:

select * from (
select 'hello' as name, null as val from dual
union
select 'yelow' as name, 20 as val from dual
) where name = '&nam'
-- val = &val;
--This will give a prompt on SQL developer and you need to enter the value of &nam
--Use single quote for string values
--Dont use single quote for numeric values
--you can ue multiple substitution variables too like shown below:

select name, &col_name from (
select 'hello' as name, null as val from dual
union
select 'yelow' as name, 20 as val from dual
union
select 'wellow' as name, null as val from dual
union
select 'zello' as name, 50 as val from dual
) where &where_clause
Order by &order_clause;

you can enter the below values in prompt:
&col_name: val
&where_clause: name = 'hello'
&order_clause: name DESC

--To avoid manually inserting this value again and again you can set this value in Define which would be valid for that whole session

DEFINE nam='hello';

select * from (
select 'hello' as name, null as val from dual
union
select 'yelow' as name, 20 as val from dual
union
select 'wellow' as name, null as val from dual
union
select 'zello' as name, 50 as val from dual
) where name = '&nam';

UNDEFINE nam;

--To change the prompt message you can use the below way, variable will persist for the session:
ACCEPT NAM PROMPT 'Please enter the name of user';

select * from (
select 'hello' as name, null as val from dual
union
select 'yelow' as name, 20 as val from dual
) where name = '&nam';

UNDEFINE nam;


-- If you define a variable using && then it will persist for the whole session and will not ask for its value again and again
select * from (
select 'hello' as name, null as val from dual
union
select 'yelow' as name, 20 as val from dual
) where name = '&&nam';

UNDEFINE nam;
--so it assigns and defines at the same time when user is prompted for input;
-- If using double ampersand followed by single ampersand for same variable in same query then the value
will be directly transferred to the single ampersand

select &&col_name from (
select 'hello' as name, null as val from dual
union
select 'yelow' as name, 20 as val from dual
) ORDER by &col_name;

--To prevent Oracle from considering '&' as variable prompt you can set DEFINE OFF:
SET DEFINE OFF;
select * from dual where name= 'R&D'

--You can set VERIFY ON/OFF to print the SQL statement in script output before and after the substitution:
SET VERIFY ON;
select * from (
select 'hello' as name, null as val from dual
) where name = '&nam';

script output >> old: select * from (
                      select 'hello' as name, null as val from dual
                      ) where name = '&nam';
                 new: select * from (
                      select 'hello' as name, null as val from dual
                      ) where name = 'hello';

CHARACTER FUNCTIONS
---------------------
Case Conversion functions (LOWER, UPPER, INITCAP)
Character manipulation function (CONCAT, SUBSTR, LENGTH, INSTR, LPAD|RPAD, TRIM, REPLACE)

SELECT TRIM(' ' FROM ' HULK ') tab_1 from DUAL;
SELECT TRIM(LEADING ' ' FROM ' HULK ') tab_1 from DUAL;
SELECT TRIM(TRAILING ' ' FROM ' HULK ') tab_1 from DUAL;
SELECT TRIM(BOTH ' ' FROM ' HULK ') tab_1 from DUAL;
SELECT TRIM('k' FROM ' HULK ') tab_1 from DUAL;

DATES
-----------------
Date + Number: Adds no. of days to date
Date - Number: Subtracts no. of days to date
Date - Date: Subtracts date - date and returns no of days
Date + number/24: Adds number of hours to date

Date RR format: DD-MON-RR
RR takes either 20th century year or 21st century year
if RR is between 50 to 99 then it takes 19XX year. If RR is between 0 to 49 then it takes 20XX year

Select MONTHS_BETWEEN(SYSDATE, HIRE_DATE) from tab_1;
using (sysdate - hire_date)/30 will not give accurate result as all months are not of 30 days

ADD_MONTHS(sysdate, 2) or ADD_MONTHS(sysdate, -2)

NEXT_DAY(SYSDATE, 'FRIDAY') will give the next friday after given date
NEXT_DAY(SYSDATE, 2) will give next Monday after given date (As pr NLS_DATE_LANGUAGE set by DB admin it usually defaults to Sunday = 1 upto Saturday = 7)

LAST_DAY(SYSDATE) gives last date of month

ROUND(HIRE_DATE, 'MONTH') if date between 1 to 15 then returns 1st date of month. If date between 16 to 30 then returns 1st date of next month
TRUNC(HIRE_DATE, 'MONTH') Always returns 1st date of month. like 01-Feb-18

ROUND(HIRE_DATE, 'YEAR') if month between 1 to 6 then returns 1st date of year like 01-JAN-18. If month between 7 to 12 then returns 1st date of next year like 01-JAN-19
TRUNC(HIRE_DATE, 'YEAR') Always returns 1st date of year. like 01-JAN-18

